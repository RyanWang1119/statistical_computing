---
title: "week5"
author: "Ryan Wang"
date: "2024-09-24"
output: html_document
---

```{r setup, include=FALSE}
knitr::write_bib("rmarkdown", file = "my-refs.bib")
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(here)
```

# Functional loops
## lapply(): 
Loop over a list and evaluate a function on each element. returns a list.
```{r}
x <- list(a = 1:5, b = rnorm(10))
x
lapply(x, mean)
```

```{r}
x <- 1:4
lapply(x, runif)
lapply(x, runif, min=0, max=10)
```
Functions that you pass to lapply() may have other arguments.

## sapply():
The sapply() function behaves similarly to lapply().
simplify the return: 
If the result is a list where every element is length 1, then a vector is returned

If the result is a list where every element is a vector of the same length (> 1), a matrix is returned.

If it canâ€™t figure things out, a list is returned.
```{r}
x <- list(a = 1:4, b = rnorm(10), c = rnorm(20, 1), d = rnorm(100, 5))
lapply(x, mean)
sapply(x, mean)
```


## mapply(): 
multivariate version of lapply():
```{r}
x <- 1: 10
y <- 1: 10

my_sum <- function(a, b) {
    a + b
}

## Same but with an extra check to make sure that 'a' and 'b'
## have the same lengths.
my_sum <- function(a, b) {
    ## Check that a and b are of the same length
    stopifnot(length(a) == length(b))
    a + b
}

## Apply mapply() to our function my_sum() with the inputs 'x' and 'y'
mapply(my_sum, x, y)
```

# Split
```{r}
x <- c(rnorm(n=10,0), rnorm(n=10,10), rnorm(n=10,100))
f <- gl(3, 10) # generate factor levels
f
split(x, f)

lapply(split(x, f), mean)
```

## Split a dataframe
```{r}
library("datasets")
head(airquality)

s <- split(airquality, airquality$Month)
str(s)
s

lapply(s, function(x) {
    colMeans(x[, c("Ozone", "Solar.R", "Wind")],
             na.rm = TRUE)
})

sapply(s, function(x) {
    colMeans(x[, c("Ozone", "Solar.R", "Wind")],
             na.rm = TRUE)
})
```

# Handle error
## message
A generic notification/diagnostic message produced by the message() function; execution of the function continues
```{r}
print_message3 <- function(x) {
    if (length(x) > 1L) {
        stop("'x' has length > 1")
    }
    if (is.na(x)) {
        print("x is a missing value!")
    } else if (x > 0) {
        print("x is greater than zero")
    } else {
        print("x is less than or equal to zero")
    }
    invisible(x)
}

print_message3(2)
print_message3(NA)
print_message3(c(1,2))
```

## call = False
```{r}
print_message3_no_call <- function(x) {
    if (length(x) > 1L) {
        stop("'x' has length > 1", call. = FALSE)
    }
    if (is.na(x)) {
        print("x is a missing value!")
    } else if (x > 0) {
        print("x is greater than zero")
    } else {
        print("x is less than or equal to zero")
    }
    invisible(x)
}

print_message3_no_call(c(1,2))
``` 
Does not display "Error in print_message3(c(1, 2)) :".

## tidyverse version
base::stop() with rlang::abort()

base::warning() with rlang::warn()

base::message() with rlang::inform()
```{r}
print_message3_tidyverse <- function(x) {
    if (length(x) > 1L) {
        rlang::abort("'x' has length > 1")
    }
    if (is.na(x)) {
        rlang::warn("x is a missing value!")
    } else if (x > 0) {
        rlang::inform("x is greater than zero")
    } else {
        rlang::inform("x is less than or equal to zero")
    }
    invisible(x)
}

print_message3_tidyverse(c(1,2))
print_message3_tidyverse(NA)
```

## cli package
```{r}
print_message3_cli <- function(x) {
    if (length(x) > 1L) {
        len <- length(x)

      
        cli::cli_abort(
            c(
                "This function is not vectorized:",
                "i" = "{.var x} has length {len}.",
                "x" = "{.var x} must have length 1.",
                ">" = "Try using {.code purrr::map(x, print_message3_cli)} to loop 
                your input {.var x} on this function."
            )
        )
    }
    if (is.na(x)) {
        rlang::warn("x is a missing value!")
    } else if (x > 0) {
        rlang::inform("x is greater than zero")
    } else {
        rlang::inform("x is less than or equal to zero")
    }
    invisible(x)
}

set.seed(20230928)
print_message3_cli(-1:1)
```

## Vectorize the function
```{r}
print_message4 <- Vectorize(print_message3)
out <- print_message4(c(-1, 2))
```
print_message3 takes single value. Works fine after vectorized.

## traceback
Prints out the function call stack after an error has occured.
```{r}
lm(y~x)
traceback()
```

